#+OPTIONS: toc:nil
# #+LaTeX_CLASS: koma-article 

#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=169]
#+OPTIONS: H:2

#+LaTex_HEADER: \usepackage{khpreamble}
#+LaTex_HEADER: \usepackage{amssymb}
#+LaTex_HEADER: \usepgfplotslibrary{groupplots}
#+LaTex_HEADER: \usepackage{gensymb}

#+LaTex_HEADER: \newcommand*{\shift}{\operatorname{q}}

#+title: Incremental encoder
#+author: Kjartan Halvorsen
# #+date: 2021-02-15

* What do I want the students to understand?			   :noexport:
  - How the incremental encoder works
    
* Which activities will the students do?			   :noexport:
  - Excercises on speed, angle, number of rotations

* Sensors in general
** Sensors
  #+begin_export latex
    \begin{center}
    \begin{tikzpicture}[scale=0.6, node distance=22mm, block/.style={rectangle, draw, minimum width=15mm, inner sep=8pt}, sumnode/.style={circle, draw, inner sep=2pt}]

      \node[coordinate] (input) {};
      \node[sumnode, right of=input, node distance=20mm] (sumerr) {\tiny $\Sigma$};
      \node[block, right of=sumerr, node distance=30mm] (fb)  {Controller};
      \node[block, right of=fb, node distance=40mm] (plant)  {Plant};
      \node[block, orange!80!black, thick, below of=plant, node distance=16mm] (sensor)  {Sensor};

      \node[coordinate, above of=plant, node distance=14mm] (disturbance) {};
      \node[coordinate, right of=plant, node distance=40mm] (output) {};

      \draw[->] (input) -- node[above, pos=0.3] {reference} (sumerr);
      \draw[->] (sumerr) -- node[above] {error} (fb);
      \draw[->] (fb) -- node[above, align=left,] {control\\action} (plant);
      \draw[->] (plant) -- node[coordinate] (meas) {} node[above,] {output} (output);
      \draw[->] (disturbance) -- node[right, pos=0.2] {disturbance} (plant);
      \draw[->] (meas) |- (sensor) -| node[right, pos=0.9] {-} (sumerr);
      \draw[->, red!80!black, thick] (sensor) ++(0, -22mm) -- node[near start, right] {error, noise} (sensor);
      \end{tikzpicture}
    \end{center}
    #+end_export

    #+BEAMER: \pause
    It is *inevitable* that sensors introduce *noise* into the system.
    
** Sensors
  #+begin_export latex
    \begin{center}
    \begin{tikzpicture}[scale=0.6, node distance=22mm, block/.style={rectangle, draw, minimum width=15mm, inner sep=8pt}, sumnode/.style={circle, draw, inner sep=2pt}]

      \node[coordinate] (input) {};
      \node[sumnode, right of=input, node distance=20mm] (sumerr) {\tiny $\Sigma$};
      \node[block, right of=sumerr, node distance=30mm] (fb)  {Controller};
      \node[block, right of=fb, node distance=40mm] (plant)  {Plant};
      \node[sumnode, orange!80!black, thick, below of=plant, node distance=16mm] (sensor)  {\tiny $\Sigma$};


      \node[coordinate, above of=plant, node distance=14mm] (disturbance) {};
      \node[coordinate, right of=plant, node distance=40mm] (output) {};

      \draw[->] (input) -- node[above, pos=0.3] {reference} (sumerr);
      \draw[->] (sumerr) -- node[above] {error} (fb);
      \draw[->] (fb) -- node[above, align=left,] {control \\action} (plant);
      \draw[->] (plant) -- node[coordinate] (meas) {} node[above, orange!80!black] {$y$} (output);
      \draw[->] (disturbance) -- node[right, pos=0.2] {disturbance} (plant);
      \draw[->] (meas) |- (sensor) -| node[pos = 0.2, below] {$y_m(t) = \textcolor{orange!80!black}{y(t)} + \textcolor{red!80!black}{n(t)}$} node[right, pos=0.9] {-} (sumerr);
      \draw[->, red!80!black, thick] (sensor) ++(0, -22mm) -- node[near start, right] {noise} (sensor);
      \end{tikzpicture}
    \end{center}
    #+end_export

    It is important to know the (statistical) characteristics of the measurement error!

    #+begin_export latex
    \begin{center}
    \begin{tikzpicture}
      \begin{axis}[clip=false,width=6.5cm, height=3.5cm, xticklabel=\empty, yticklabel=\empty,
      axis lines=middle,
      ylabel={$f_n$}, xlabel={$n$}]
      \addplot[red!70!black, no marks, smooth, domain=-2:2, samples=30] {exp(-pow(x,2))};
      \node at (axis cs: 2,0.8) {easy};
      \end{axis}
   %   \begin{axis}[clip=false, xshift=5cm, width=4.5cm, height=3.5cm, xticklabel=\empty, yticklabel=\empty,
   %   axis lines=middle,
   %   ylabel={$f_n$}, xlabel={$n$}]
   %   \addplot[red!70!black, no marks, smooth, domain=-4:6, samples=60] {exp(-pow((x-2)*2,2)) + exp(-pow((x+0.5)*2,2)) };
   %   \node at (axis cs: 4,0.8) {difficult};
   %   \end{axis}
      \begin{axis}[clip=false, xshift=8cm, width=6.5cm, height=3.5cm, xticklabel=\empty, yticklabel=\empty,
      axis lines=middle,
      ylabel={$f_n$}, xlabel={$n$}]
      \addplot[red!70!black, no marks, smooth, domain=-2:4, samples=60] {(x<0)*exp(-pow((x)*2,2)) + (x>=0)/(1+x) };
      \node at (axis cs: 4,0.8) {difficult};
      \end{axis}
    \end{tikzpicture}
    \end{center}
    #+end_export


** Sensors - characteristics
*** Graphics
:PROPERTIES:
:BEAMER_col: 0.4
:END:

   - *Accuracy* How correct is the measurement on average
   - *Precision* How much do the errors vary (standard deviation)
   - *Sensitivity/resolution* The smallest change in the measured variable that can be detected
   - *Delay* \(y_m(t) = y(t-\tau) + n(t)\)
   - *Sampling and digitalization*

*** Text
:PROPERTIES:
:BEAMER_col: 0.6
:END:

#+BEAMER: \pause

     #+begin_center
     \includegraphics[width=0.96\textwidth]{../../figures/sampling-digitalization}
     #+end_center

* Encoder
** Incremental encoder
   #+begin_export latex
   \begin{center}
   \includegraphics[width=0.7\textwidth]{../../figures/encoder-im.jpg}
   {\tiny Source: \url{https://www.sciencedirect.com/topics/engineering/incremental-encoder}}
   \end{center}
   #+end_export

** Incremental encoder
   #+begin_export latex
   \begin{center}
   \includegraphics[width=0.4\textwidth]{../../figures/encoder-disc}
   \includegraphics[width=0.5\textwidth]{../../figures/encoder-signals}
   \end{center}
   #+end_export

   /Pulses Per Revolution (PPR)/ is 4 en the example. Each aperture covers a sector of \(\frac{360\degree}{2 \times PPR} = 45\degree\).

** Incremental encoder
   #+begin_export latex
   \begin{center}
   \includegraphics[width=0.4\textwidth]{../../figures/encoder-disc}
   \includegraphics[width=0.5\textwidth]{../../figures/encoder-signals}
   \end{center}
   #+end_export

   *Activity* If both rising *and* falling edges of both signals \textcolor{blue!80!black}{A} and \textcolor{red!80!black}{B}, what is the smallest change in angle that can be detected (/sensitivity/ of the sensor)?

   
** Incremental encoder

   #+begin_export latex
   \begin{center}
   \includegraphics[width=0.4\textwidth]{../../figures/encoder-disc}
   \includegraphics[width=0.5\textwidth]{../../figures/encoder-signals}
   \end{center}
   #+end_export

   *Activity* In the above example, does the encoder turn clockwise (CW) or counter-clockwise (CCW)?


** Incremental encoder - velocity
*** Graphics
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+begin_center
    \includegraphics[width=\textwidth]{../../figures/encoder-signals-nonuniform}
    #+end_center
*** Text
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    We want to find the angular velocity at the time-instant $t=\unit{6.5}{\milli\second}$. For the encoder we have PPR=8, and both rising and falling edges of both signals A and B are counted, resulting in 32 counts per revolution.

    *Activity* Calculate the angular velocity in rad/s for case *(a)* using a sampling period of $\Delta t=\unit{0.5}{\milli\second}$, and for case *(b)* using a sampling period of $\Delta t=\unit{5}{\milli\second}$.
    
*** Calculations                                                   :noexport:

#+BEGIN_SRC python :session :results output 
  import numpy as np
  CPR = 32.0
  dc = 5
  dt = 5e-3
  v = dc/dt/CPR*2*np.pi
  print("Vel = %0.1f rad/s" %v)

#+END_SRC

#+RESULTS:
: Vel = 196.3 rad/s


   
   


** Incremental encoder - Velocity from frequency of the counts
*** Graphics
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+begin_center
    \includegraphics[width=\textwidth]{../../figures/encoder-signals-freqs}
    #+end_center
*** Text
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    The velocity can be measured by the inverse of the time between subsequent pulses. In the example there is an interval of \unit{1}{\milli\second} between the two pulses. The velocity becomes
    \begin{align*}
     v &= 1 \, \text{pulses/ms} = \frac{1/32 \, \text{revolutions}}{\unit{10^{-3}}{\second}}\\
     &= \unit{\frac{2\pi}{32}\times 1000}{\rad\per\second} = \unit{196.3}{\rad\per\second}
     \end{align*}
    
*** Calculations                                                   :noexport:

#+BEGIN_SRC python :session :results output 
  import numpy as np
  CPR = 32.0
  dc = 5
  dt = 5e-3
  v = dc/dt/CPR*2*np.pi
  print("Vel = %0.1f rad/s" %v)

#+END_SRC

#+RESULTS:
: Vel = 196.3 rad/s


   
   


** Incremental encoder - Velocity from frequency of the counts
*** Graphics
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+begin_center
    \includegraphics[width=\textwidth]{../../figures/encoder-signals-nonuniform}
    #+end_center
*** Text
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    *Activity* Calculate the velocity at \(t=\unit{11}{\milli\second}\)!
    
*** Calculations                                                   :noexport:

#+BEGIN_SRC python :session :results output 
  import numpy as np
  CPR = 32.0
  dc = 1
  dt = 0.65e-3
  v = dc/dt/CPR*2*np.pi
  print("Vel = %0.1f rad/s" %v)

#+END_SRC

#+RESULTS:
: Vel = 302.1 rad/s


   
   


** Incremental encoder - Velocity from frequency of the counts     :noexport:

*** Graphics
    :PROPERTIES:
    :BEAMER_col: 0.7
    :END:

    #+begin_center
    \includegraphics[width=0.8\textwidth]{../../figures/encoder-signal-freqs2}
    #+end_center

*** Text
    :PROPERTIES:
    :BEAMER_col: 0.3
    :END:

    The velocity is calculated when new counts arrive.

** Simulink exercise - decoder

Complete the simulink diagram so that the angular velocity is correctly estimated.

    #+begin_center
    \includegraphics[width=0.8\textwidth]{../../figures/simulink-encoder-decoder-exc.png}
    #+end_center
